//
//  SeasonViewController.swift
//  KinoPub
//
//  Created by Maksim Kolesnik on 07/03/2020.
//  Copyright (c) 2020 Maksim Kolesnik. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import UIKit
import DTModelStorage
import DTTableViewManager
import Combine
import AVKit
import AVFoundation
import Files

public final class SeasonViewController: UIViewController, TransitionView {

    // MARK: - Private

    fileprivate lazy var _tableView: UITableView = {
        let tableView = UITableView(frame: .zero, style: .grouped)
        tableView.delegate = self
        return tableView
    }()

    private var disposable = Set<AnyCancellable>()

    public let presenter: SeasonViewOutput
    public init(presenter: SeasonViewOutput) {
        self.presenter = presenter
        super.init(nibName: nil, bundle: nil)
    }

    public required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") }

    // MARK: - Lifecycle

    public override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        presenter.didTriggerViewReadyEvent()
    }

    private func setupContent() {
        view.addSubview(tableView)
    }

    private func setupLayout() {

        tableView.translatesAutoresizingMaskIntoConstraints = false
        tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true
        tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true
        tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true
        tableView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true
    }
}

// MARK: - SeasonViewInput

extension SeasonViewController: SeasonViewInput {

}

// MARK: - SeasonPresenterOutput

extension SeasonViewController: SeasonPresenterOutput {
    public func setupInitialState() {
        setupContent()
        setupLayout()
        presenter.requestEpisodes()
            .subscribe(manager.memoryStorage.setItems())

        manager.register(TableViewCell.self)
        manager.didSelect(TableViewCell.self, {  (_, _, _) in
            //            self?.presenter.didSelect(model: model)
        })

        manager.configure(TableViewCell.self, {  (_, _, _) in

        })

    }

}

extension SeasonViewController: SeasonViewControllerCellDelegate {

//        let vc = VLCPlayerViewController(nibName: nil, bundle: nil)
//        vc.episode = model
//        self.present(vc, animated: true, completion: nil)
//        return
//        let playbackController = PlaybackService.sharedInstance()
//        if let url = (model.files.first?.url.hls4).flatMap({ URL(string: $0) }) {
//            let player = AVPlayer(playerItem: AVPlayerItem.init(url: url))
//            player.appliesMediaSelectionCriteriaAutomatically = true
//            let controller = AVPlayerViewController()
//            controller.player = player
//            self.present(controller, animated: true, completion: nil)
//        }
//        return
//        do {
//            throw NSError(domain: "2312", code: 232, userInfo: nil)
//            let videoFile =
//            guard let videoURL = (model.files.first(where: { $0.qualityID == 1 })?.url.http).flatMap({ URL(string: $0) }) else { return }
//            let lastPathComponent = videoURL.lastPathComponent
//            let documentDirectoryPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first ?? NSTemporaryDirectory()
//            let documentDirectoryUrl = URL(fileURLWithPath: documentDirectoryPath).appendingPathComponent(lastPathComponent)
//            let videoAsset = AVURLAsset.init(url: documentDirectoryUrl)
//            let videoPlusSubtitles = AVMutableComposition()
//            guard let videoTrack = videoPlusSubtitles.addMutableTrack(withMediaType: .video, preferredTrackID: kCMPersistentTrackID_Invalid) else { return }
//            try videoTrack.insertTimeRange(CMTimeRange.init(start: .zero, duration: videoAsset.duration),
//                                           of: videoAsset.tracks(withMediaType: .video).first!,
//                                           at: .zero)
//            guard let subtitlesURL = (model.subtitles.first?.url).flatMap({ URL(string: $0) }) else { return }
//            let localSubtitlesURL = URL(fileURLWithPath: documentDirectoryPath).appendingPathComponent(subtitlesURL.lastPathComponent)
//            let subtitleAsset = AVURLAsset(url: localSubtitlesURL)
//            let ass = AVURLAsset.audiovisualMIMETypes()
//            print(subtitleAsset)
//            print(subtitleAsset.tracks)
//            print(subtitleAsset.trackGroups)
//            guard let subtitleTrack = videoPlusSubtitles.addMutableTrack(withMediaType: .text, preferredTrackID: kCMPersistentTrackID_Invalid) else { return }
//            try subtitleTrack.insertTimeRange(CMTimeRange.init(start: .zero, duration: videoAsset.duration),
//                                          of: subtitleAsset.tracks(withMediaType: .text).first!,
//                                          at: .zero)
//            let player = AVPlayer(playerItem: AVPlayerItem.init(asset: videoPlusSubtitles))
//            player.appliesMediaSelectionCriteriaAutomatically = true
//            let controller = AVPlayerViewController()
//            controller.player = player
//            self.present(controller, animated: true, completion: nil)
//        } catch {
//
//        }
//        return

//        switch state {
//        case .startDownload:
//            downloadButton.progress = 0
//            downloadButton.state = .downloading
//            self.presenter.download(model)
//            .sink(receiveCompletion: { (completion) in
//
//            }, receiveValue: { (progress) in
//                let fractionCompleted = progress.fractionCompleted
//                print(fractionCompleted)
//                downloadButton.progress = CGFloat(fractionCompleted)
//            })
//            .store(in: &disposable)
//           DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
//               downloadButton.state = .downloading
//            }
//        case .pending, .downloading, .downloaded:
//            break
//        }
    
}

extension SeasonViewController: UITableViewDelegate {

    public func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return 35
    }

    public func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
    }

    public func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 44
    }
}

extension SeasonViewController: DTTableViewManageable {
    public var tableView: UITableView! {
        return _tableView
    }
}

extension SeasonViewController {
    public final class TableViewCell: UITableViewCell, ModelTransfer, DownloadButtonDelegate {
        private var disposable = Set<AnyCancellable>()
        private var model: EpisodeViewModel?
        private lazy var containerView: UIView = {
            let view = UIView(frame: .zero)
            view.translatesAutoresizingMaskIntoConstraints = false
            return view
        }()

        private lazy var downloadButton: DownloadButton = {
            let downloadButton = DownloadButton(frame: .zero)
            downloadButton.translatesAutoresizingMaskIntoConstraints = false
//            downloadButton.delegate = self
            return downloadButton
        }()

        private lazy var titleLabel: UILabel = {
            let label = UILabel(frame: .zero)
            label.translatesAutoresizingMaskIntoConstraints = false
            return label
        }()

        public override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
            super.init(style: UITableViewCell.CellStyle.default, reuseIdentifier: reuseIdentifier)
            contentView.addSubview(containerView)
            containerView.addSubview(titleLabel)
            containerView.addSubview(downloadButton)

            containerView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor).isActive = true
            containerView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor).isActive = true
            containerView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor).isActive = true
            containerView.topAnchor.constraint(equalTo: contentView.topAnchor).isActive = true

            titleLabel.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 16).isActive = true
            titleLabel.centerYAnchor.constraint(equalTo: containerView.centerYAnchor).isActive = true
            titleLabel.trailingAnchor.constraint(equalTo: downloadButton.leadingAnchor, constant: 8).isActive = true

            downloadButton.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -8).isActive = true
            downloadButton.widthAnchor.constraint(equalToConstant: 44).isActive = true
            downloadButton.centerYAnchor.constraint(equalTo: containerView.centerYAnchor).isActive = true

        }

        public required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") }

        public func update(with model: EpisodeViewModel) {
            self.titleLabel.text = model.model.title
            self.model = model
        }

        public func downloadButton(_ downloadButton: DownloadButton, tappedWithState state: DownloadButton.State) {
            switch state {
            case .startDownload:
                downloadButton.state = .pending
                model?.download()
                    .sink(receiveCompletion: { (completion) in
                        switch completion {
                        case .failure(let error):
                            print(error)
                            downloadButton.state = .startDownload
                        case .finished:
                            downloadButton.state = .downloaded
                        }
                    }, receiveValue: { [weak self] (progress) in
                        guard let self = self else { return }
                        if downloadButton.state != .downloading {
                            downloadButton.state = .downloading
                        }
                        let fractionCompleted = progress.fractionCompleted
                        self.downloadButton.progress = CGFloat(fractionCompleted)
                    })
                    .store(in: &disposable)
            case .downloading, .pending:
                model?.cancel()
            case .downloaded:
                print("not implemented")
            }
        }
    }
}

private protocol SeasonViewControllerCellDelegate: AnyObject {
}
